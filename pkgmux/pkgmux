#!/usr/bin/env bash
# pkgmux - Declarative package management for dotfiles
set -euo pipefail

PKGMUX_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
APPS_DIR="$(dirname "$PKGMUX_DIR")/apps"

# Source core modules
source "$PKGMUX_DIR/core/os.sh"
source "$PKGMUX_DIR/core/util.sh"
source "$PKGMUX_DIR/core/loader.sh"
source "$PKGMUX_DIR/core/selector.sh"
source "$PKGMUX_DIR/core/requires.sh"
source "$PKGMUX_DIR/core/progress.sh"

# Source handlers
for handler in "$PKGMUX_DIR"/handlers/*.sh; do
    [[ -f "$handler" ]] && source "$handler"
done

# Check bootstrap dependencies
check_bootstrap_deps() {
    local missing=()
    command_exists jq || missing+=("jq")
    command_exists yq || missing+=("yq")

    if [[ ${#missing[@]} -gt 0 ]]; then
        log_error "Missing required dependencies: ${missing[*]}"
        log_info "Install them manually following official instructions:"
        log_info "  jq: https://jqlang.github.io/jq/download/"
        log_info "  yq: https://github.com/mikefarah/yq#install"
        exit 1
    fi
}

# Process a single app with a given action
process_app() {
    local action="$1"
    local app_name="$2"

    local app_json
    if ! app_json=$(load_app "$app_name" "$APPS_DIR" 2>/dev/null); then
        log_error "Failed to load app: $app_name"
        return 1
    fi

    local install_entry
    install_entry=$(select_install_entry "$app_json")

    if [[ -z "$install_entry" ]]; then
        log_skip "$app_name (no install entry for $PKGMUX_OS)"
        return 0
    fi

    local handler_type
    handler_type=$(get_handler_type "$install_entry")

    if [[ -z "$handler_type" ]]; then
        log_error "$app_name: No handler type specified"
        return 1
    fi

    # Check requires before install
    if [[ "$action" == "install" ]]; then
        if ! check_requires "$app_json"; then
            return 1
        fi
    fi

    # Call the appropriate handler function
    local handler_func="handler_${handler_type}_${action}"
    if ! declare -f "$handler_func" &>/dev/null; then
        log_error "$app_name: Unknown handler: $handler_type"
        return 1
    fi

    "$handler_func" "$app_name" "$install_entry" "$app_json"
}

# Commands
cmd_install() {
    local apps=("$@")

    if [[ ${#apps[@]} -eq 0 ]]; then
        mapfile -t apps < <(list_apps "$APPS_DIR")
    fi

    local failed=0
    for app in "${apps[@]}"; do
        if ! process_app install "$app"; then
            ((failed++)) || true
        fi
    done

    return $failed
}

cmd_upgrade() {
    local apps=("$@")

    if [[ ${#apps[@]} -eq 0 ]]; then
        mapfile -t apps < <(list_apps "$APPS_DIR")
    fi

    local failed=0
    for app in "${apps[@]}"; do
        if ! process_app upgrade "$app"; then
            ((failed++)) || true
        fi
    done

    return $failed
}

cmd_uninstall() {
    local apps=("$@")

    if [[ ${#apps[@]} -eq 0 ]]; then
        log_error "Please specify apps to uninstall"
        return 1
    fi

    local failed=0
    for app in "${apps[@]}"; do
        if ! process_app uninstall "$app"; then
            ((failed++)) || true
        fi
    done

    return $failed
}

cmd_list() {
    list_apps "$APPS_DIR"
}

cmd_doctor() {
    local verbose=false
    local json_output=false
    local remaining_args=()

    # Parse flags
    for arg in "$@"; do
        case "$arg" in
            -v|--verbose) verbose=true ;;
            --json) json_output=true ;;
            *) remaining_args+=("$arg") ;;
        esac
    done
    set -- "${remaining_args[@]+"${remaining_args[@]}"}"

    local apps=("$@")

    if [[ ${#apps[@]} -eq 0 ]]; then
        mapfile -t apps < <(list_apps "$APPS_DIR")
    fi

    # Progress bar wrapper functions: clear bar before log, redraw after
    _doctor_log_ok()    { progress_clear; log_ok    "$@"; _progress_draw; }
    _doctor_log_warn()  { progress_clear; log_warn  "$@"; _progress_draw; }
    _doctor_log_error() { progress_clear; log_error "$@"; _progress_draw; }
    _doctor_log_skip()  { progress_clear; log_skip  "$@"; _progress_draw; }

    local count_installed=0
    local count_not_installed=0
    local count_outdated=0
    local count_pinned_drift=0
    local count_missing_requires=0
    local json_results=()

    $json_output || progress_start "${#apps[@]}"

    local _i=0
    for app in "${apps[@]}"; do
        ((_i++)) || true
        $json_output || progress_update "$_i" "$app"
        local app_json
        if ! app_json=$(load_app "$app" "$APPS_DIR" 2>/dev/null); then
            $json_output || _doctor_log_error "$app: failed to load definition"
            continue
        fi

        local install_entry
        install_entry=$(select_install_entry "$app_json")

        if [[ -z "$install_entry" ]]; then
            if $json_output; then
                json_results+=("$(jq -n --arg name "$app" '{
                    name: $name,
                    installed: false,
                    version: null,
                    latest_version: null,
                    pinned_version: null,
                    outdated: false,
                    pinned_drift: false,
                    missing_requires: [],
                    skipped: true
                }')")
            else
                $verbose && _doctor_log_skip "$app (no install entry for $PKGMUX_OS)" || true
            fi
            continue
        fi

        local handler_type
        handler_type=$(get_handler_type "$install_entry")

        # Check requires
        local missing_reqs=()
        local requires
        requires=$(echo "$app_json" | jq -r '.requires // [] | .[]')
        for req in $requires; do
            if ! command_exists "$req"; then
                missing_reqs+=("$req")
            fi
        done
        if [[ ${#missing_reqs[@]} -gt 0 ]]; then
            ((count_missing_requires++)) || true
        fi

        # Check installation
        local status_func="handler_${handler_type}_status"
        local is_installed=false
        if declare -f "$status_func" &>/dev/null && "$status_func" "$app" "$install_entry" "$app_json" &>/dev/null; then
            is_installed=true
        fi

        if ! $is_installed; then
            ((count_not_installed++)) || true
            if $json_output; then
                local missing_reqs_json="[]"
                if [[ ${#missing_reqs[@]} -gt 0 ]]; then
                    missing_reqs_json=$(printf '%s\n' "${missing_reqs[@]}" | jq -R . | jq -s .)
                fi
                json_results+=("$(jq -n --arg name "$app" --argjson missing_reqs "$missing_reqs_json" '{
                    name: $name,
                    installed: false,
                    version: null,
                    latest_version: null,
                    pinned_version: null,
                    outdated: false,
                    pinned_drift: false,
                    missing_requires: $missing_reqs,
                    skipped: false
                }')")
            else
                if [[ ${#missing_reqs[@]} -gt 0 ]]; then
                    _doctor_log_error "$app: not installed [missing requires: ${missing_reqs[*]}]"
                else
                    _doctor_log_error "$app: not installed"
                fi
            fi
            continue
        fi

        ((count_installed++)) || true

        # Get current version
        local current_version=""
        local version_func="handler_${handler_type}_current_version"
        if declare -f "$version_func" &>/dev/null; then
            current_version=$("$version_func" "$app" "$install_entry" "$app_json" 2>/dev/null) || true
        fi
        local version_display="${current_version:-unknown}"

        # Check outdated (current vs latest)
        local outdated_msg=""
        local is_outdated=false
        local latest_version=""
        local can_check_outdated=true
        if [[ "$handler_type" == "custom" ]]; then
            local latest_cmd
            latest_cmd=$(_custom_get_latest_cmd "$install_entry")
            [[ -z "$latest_cmd" ]] && can_check_outdated=false
        fi

        if $can_check_outdated && [[ -n "$current_version" && "$current_version" != "installed, version unknown" ]]; then
            local latest_func="handler_${handler_type}_latest_version"
            if declare -f "$latest_func" &>/dev/null; then
                latest_version=$("$latest_func" "$app" "$install_entry" "$app_json" 2>/dev/null) || true
                if [[ -n "$latest_version" && "$current_version" != "$latest_version" ]]; then
                    outdated_msg="update available (latest: $latest_version)"
                    is_outdated=true
                    ((count_outdated++)) || true
                fi
            fi
        fi

        # Check pinned version drift (custom handler with pinned_version)
        local drift_msg=""
        local has_pinned_drift=false
        local pinned_version=""
        if [[ "$handler_type" == "custom" ]]; then
            pinned_version=$(echo "$install_entry" | jq -r '.pinned_version // empty')
            if [[ -n "$pinned_version" && -n "$current_version" && "$current_version" != "installed, version unknown" && "$current_version" != "$pinned_version" ]]; then
                drift_msg="pinned version drift (pinned: $pinned_version)"
                has_pinned_drift=true
                ((count_pinned_drift++)) || true
            fi
        fi

        if $json_output; then
            local missing_reqs_json="[]"
            if [[ ${#missing_reqs[@]} -gt 0 ]]; then
                missing_reqs_json=$(printf '%s\n' "${missing_reqs[@]}" | jq -R . | jq -s .)
            fi
            # Normalize version values: treat "installed, version unknown" and empty as null
            local ver_json="null"
            if [[ -n "$current_version" && "$current_version" != "installed, version unknown" ]]; then
                ver_json=$(jq -n --arg v "$current_version" '$v')
            fi
            local latest_json="null"
            if [[ -n "$latest_version" ]]; then
                latest_json=$(jq -n --arg v "$latest_version" '$v')
            fi
            local pinned_json="null"
            if [[ -n "$pinned_version" ]]; then
                pinned_json=$(jq -n --arg v "$pinned_version" '$v')
            fi
            json_results+=("$(jq -n \
                --arg name "$app" \
                --argjson version "$ver_json" \
                --argjson latest_version "$latest_json" \
                --argjson pinned_version "$pinned_json" \
                --argjson outdated "$is_outdated" \
                --argjson pinned_drift "$has_pinned_drift" \
                --argjson missing_reqs "$missing_reqs_json" \
                '{
                    name: $name,
                    installed: true,
                    version: $version,
                    latest_version: $latest_version,
                    pinned_version: $pinned_version,
                    outdated: $outdated,
                    pinned_drift: $pinned_drift,
                    missing_requires: $missing_reqs,
                    skipped: false
                }')")
        else
            # Build output
            local issues=()
            [[ -n "$outdated_msg" ]] && issues+=("$outdated_msg")
            [[ -n "$drift_msg" ]] && issues+=("$drift_msg")
            [[ ${#missing_reqs[@]} -gt 0 ]] && issues+=("missing requires: ${missing_reqs[*]}")

            if [[ ${#issues[@]} -gt 0 ]]; then
                local joined
                joined=$(printf ", %s" "${issues[@]}")
                joined="${joined:2}"
                _doctor_log_warn "$app: installed ($version_display), $joined"
            else
                $verbose && _doctor_log_ok "$app: installed ($version_display)" || true
            fi
        fi
    done

    progress_done

    if $json_output; then
        printf '%s\n' "${json_results[@]}" | jq -s --argjson installed "$count_installed" \
            --argjson not_installed "$count_not_installed" \
            --argjson outdated "$count_outdated" \
            --argjson pinned_drift "$count_pinned_drift" \
            --argjson missing_requires "$count_missing_requires" \
            '{
                apps: .,
                summary: {
                    installed: $installed,
                    not_installed: $not_installed,
                    outdated: $outdated,
                    pinned_drift: $pinned_drift,
                    missing_requires: $missing_requires
                }
            }'
    else
        echo
        log_info "Summary: $count_installed installed, $count_not_installed not installed, $count_outdated outdated, $count_pinned_drift pinned drift, $count_missing_requires missing requires"
    fi
}

usage() {
    cat <<EOF
Usage: pkgmux <command> [apps...]

Commands:
  install [app...]   Install apps (all if no args)
  upgrade [app...]   Upgrade apps (all if no args)
  uninstall <app...> Uninstall specified apps
  list               List all defined apps
  doctor [-v] [--json] [app...]    Health check (all if no args)

Examples:
  pkgmux install           # Install all apps
  pkgmux install git go    # Install specific apps
  pkgmux doctor            # Run health check for all apps
  pkgmux doctor -v         # Verbose health check
  pkgmux doctor --json     # JSON output
  pkgmux doctor go fzf     # Run health check for specific apps
EOF
}

# Main
main() {
    check_bootstrap_deps

    local cmd="${1:-}"
    shift || true

    case "$cmd" in
        install)   cmd_install "$@" ;;
        upgrade)   cmd_upgrade "$@" ;;
        uninstall) cmd_uninstall "$@" ;;
        list)      cmd_list ;;
        doctor)    cmd_doctor "$@" ;;
        -h|--help|help|"")
            usage
            ;;
        *)
            log_error "Unknown command: $cmd"
            usage
            exit 1
            ;;
    esac
}

main "$@"
