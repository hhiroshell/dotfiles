#!/usr/bin/env bash
# appctl - Declarative package management for dotfiles
set -euo pipefail

APPCTL_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
APPS_DIR="$(dirname "$APPCTL_DIR")/apps"

# Source core modules
source "$APPCTL_DIR/core/os.sh"
source "$APPCTL_DIR/core/util.sh"
source "$APPCTL_DIR/core/loader.sh"
source "$APPCTL_DIR/core/selector.sh"
source "$APPCTL_DIR/core/requires.sh"

# Source handlers
for handler in "$APPCTL_DIR"/handlers/*.sh; do
    [[ -f "$handler" ]] && source "$handler"
done

# Check bootstrap dependencies
check_bootstrap_deps() {
    local missing=()
    command_exists jq || missing+=("jq")
    command_exists yq || missing+=("yq")

    if [[ ${#missing[@]} -gt 0 ]]; then
        log_error "Missing required dependencies: ${missing[*]}"
        log_info "Install them manually following official instructions:"
        log_info "  jq: https://jqlang.github.io/jq/download/"
        log_info "  yq: https://github.com/mikefarah/yq#install"
        exit 1
    fi
}

# Process a single app with a given action
process_app() {
    local action="$1"
    local app_name="$2"

    local app_json
    if ! app_json=$(load_app "$app_name" "$APPS_DIR" 2>/dev/null); then
        log_error "Failed to load app: $app_name"
        return 1
    fi

    local install_entry
    install_entry=$(select_install_entry "$app_json")

    if [[ -z "$install_entry" ]]; then
        log_skip "$app_name (no install entry for $APPCTL_OS)"
        return 0
    fi

    local handler_type
    handler_type=$(get_handler_type "$install_entry")

    if [[ -z "$handler_type" ]]; then
        log_error "$app_name: No handler type specified"
        return 1
    fi

    # Check requires before install
    if [[ "$action" == "install" ]]; then
        if ! check_requires "$app_json"; then
            return 1
        fi
    fi

    # Call the appropriate handler function
    local handler_func="handler_${handler_type}_${action}"
    if ! declare -f "$handler_func" &>/dev/null; then
        log_error "$app_name: Unknown handler: $handler_type"
        return 1
    fi

    "$handler_func" "$app_name" "$install_entry" "$app_json"
}

# Commands
cmd_install() {
    local apps=("$@")

    if [[ ${#apps[@]} -eq 0 ]]; then
        mapfile -t apps < <(list_apps "$APPS_DIR")
    fi

    local failed=0
    for app in "${apps[@]}"; do
        if ! process_app install "$app"; then
            ((failed++)) || true
        fi
    done

    return $failed
}

cmd_upgrade() {
    local apps=("$@")

    if [[ ${#apps[@]} -eq 0 ]]; then
        mapfile -t apps < <(list_apps "$APPS_DIR")
    fi

    local failed=0
    for app in "${apps[@]}"; do
        if ! process_app upgrade "$app"; then
            ((failed++)) || true
        fi
    done

    return $failed
}

cmd_uninstall() {
    local apps=("$@")

    if [[ ${#apps[@]} -eq 0 ]]; then
        log_error "Please specify apps to uninstall"
        return 1
    fi

    local failed=0
    for app in "${apps[@]}"; do
        if ! process_app uninstall "$app"; then
            ((failed++)) || true
        fi
    done

    return $failed
}

cmd_list() {
    list_apps "$APPS_DIR"
}

cmd_doctor() {
    local verbose=false
    if [[ "${1:-}" == "-v" || "${1:-}" == "--verbose" ]]; then
        verbose=true
        shift
    fi

    local apps=("$@")

    if [[ ${#apps[@]} -eq 0 ]]; then
        mapfile -t apps < <(list_apps "$APPS_DIR")
    fi

    local count_installed=0
    local count_not_installed=0
    local count_outdated=0
    local count_pinned_drift=0
    local count_missing_requires=0

    for app in "${apps[@]}"; do
        local app_json
        if ! app_json=$(load_app "$app" "$APPS_DIR" 2>/dev/null); then
            log_error "$app: failed to load definition"
            continue
        fi

        local install_entry
        install_entry=$(select_install_entry "$app_json")

        if [[ -z "$install_entry" ]]; then
            $verbose && log_skip "$app (no install entry for $APPCTL_OS)" || true
            continue
        fi

        local handler_type
        handler_type=$(get_handler_type "$install_entry")

        # Check requires
        local missing_reqs=()
        local requires
        requires=$(echo "$app_json" | jq -r '.requires // [] | .[]')
        for req in $requires; do
            if ! command_exists "$req"; then
                missing_reqs+=("$req")
            fi
        done
        if [[ ${#missing_reqs[@]} -gt 0 ]]; then
            ((count_missing_requires++)) || true
        fi

        # Check installation
        local status_func="handler_${handler_type}_status"
        local is_installed=false
        if declare -f "$status_func" &>/dev/null && "$status_func" "$app" "$install_entry" "$app_json" &>/dev/null; then
            is_installed=true
        fi

        if ! $is_installed; then
            ((count_not_installed++)) || true
            if [[ ${#missing_reqs[@]} -gt 0 ]]; then
                log_error "$app: not installed [missing requires: ${missing_reqs[*]}]"
            else
                log_error "$app: not installed"
            fi
            continue
        fi

        ((count_installed++)) || true

        # Get current version
        local current_version=""
        local version_func="handler_${handler_type}_current_version"
        if declare -f "$version_func" &>/dev/null; then
            current_version=$("$version_func" "$app" "$install_entry" "$app_json" 2>/dev/null) || true
        fi
        local version_display="${current_version:-unknown}"

        # Check outdated (current vs latest)
        local outdated_msg=""
        local can_check_outdated=true
        if [[ "$handler_type" == "custom" ]]; then
            local latest_cmd
            latest_cmd=$(_custom_get_latest_cmd "$install_entry")
            [[ -z "$latest_cmd" ]] && can_check_outdated=false
        fi

        if $can_check_outdated && [[ -n "$current_version" && "$current_version" != "installed, version unknown" ]]; then
            local latest_func="handler_${handler_type}_latest_version"
            if declare -f "$latest_func" &>/dev/null; then
                local latest_version
                latest_version=$("$latest_func" "$app" "$install_entry" "$app_json" 2>/dev/null) || true
                if [[ -n "$latest_version" && "$current_version" != "$latest_version" ]]; then
                    outdated_msg="update available (latest: $latest_version)"
                    ((count_outdated++)) || true
                fi
            fi
        fi

        # Check pinned version drift (custom handler with pinned_version)
        local drift_msg=""
        if [[ "$handler_type" == "custom" ]]; then
            local pinned_version
            pinned_version=$(echo "$install_entry" | jq -r '.pinned_version // empty')
            if [[ -n "$pinned_version" && -n "$current_version" && "$current_version" != "installed, version unknown" && "$current_version" != "$pinned_version" ]]; then
                drift_msg="pinned version drift (pinned: $pinned_version)"
                ((count_pinned_drift++)) || true
            fi
        fi

        # Build output
        local issues=()
        [[ -n "$outdated_msg" ]] && issues+=("$outdated_msg")
        [[ -n "$drift_msg" ]] && issues+=("$drift_msg")
        [[ ${#missing_reqs[@]} -gt 0 ]] && issues+=("missing requires: ${missing_reqs[*]}")

        if [[ ${#issues[@]} -gt 0 ]]; then
            local joined
            joined=$(printf ", %s" "${issues[@]}")
            joined="${joined:2}"
            log_warn "$app: installed ($version_display), $joined"
        else
            $verbose && log_ok "$app: installed ($version_display)" || true
        fi
    done

    echo
    log_info "Summary: $count_installed installed, $count_not_installed not installed, $count_outdated outdated, $count_pinned_drift pinned drift, $count_missing_requires missing requires"
}

usage() {
    cat <<EOF
Usage: appctl <command> [apps...]

Commands:
  install [app...]   Install apps (all if no args)
  upgrade [app...]   Upgrade apps (all if no args)
  uninstall <app...> Uninstall specified apps
  list               List all defined apps
  doctor [-v] [app...]    Health check (all if no args)

Examples:
  appctl install           # Install all apps
  appctl install git go    # Install specific apps
  appctl doctor            # Run health check for all apps
  appctl doctor -v         # Verbose health check
  appctl doctor go fzf     # Run health check for specific apps
EOF
}

# Main
main() {
    check_bootstrap_deps

    local cmd="${1:-}"
    shift || true

    case "$cmd" in
        install)   cmd_install "$@" ;;
        upgrade)   cmd_upgrade "$@" ;;
        uninstall) cmd_uninstall "$@" ;;
        list)      cmd_list ;;
        doctor)    cmd_doctor "$@" ;;
        -h|--help|help|"")
            usage
            ;;
        *)
            log_error "Unknown command: $cmd"
            usage
            exit 1
            ;;
    esac
}

main "$@"
